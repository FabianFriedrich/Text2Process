<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_17) on Mon Aug 16 11:17:57 PDT 2010 -->
<TITLE>
TregexPattern (Stanford JavaNLP API)
</TITLE>

<META NAME="date" CONTENT="2010-08-16">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="TregexPattern (Stanford JavaNLP API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexParserTokenManager.html" title="class in edu.stanford.nlp.trees.tregex"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.TRegexTreeReaderFactory.html" title="class in edu.stanford.nlp.trees.tregex"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?edu/stanford/nlp/trees/tregex/TregexPattern.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="TregexPattern.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
edu.stanford.nlp.trees.tregex</FONT>
<BR>
Class TregexPattern</H2>
<PRE>
<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by "><B>edu.stanford.nlp.trees.tregex.TregexPattern</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io">Serializable</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>TregexPattern</B><DT>extends <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</A><DT>implements <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io">Serializable</A></DL>
</PRE>

<P>
A TregexPattern is a <code>tgrep</code>-type pattern for matching tree
 node configurations.  Unlike <code>tgrep</code> but like Unix
 <code>grep</code>, there is no pre-indexing of the data to be searched.
 Rather there is a linear scan through the trees where matches are sought.

 <p> TregexPattern instances can be matched against instances of the <A HREF="../../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees"><CODE>Tree</CODE></A> class.
 The <A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#main(java.lang.String[])"><CODE>main(java.lang.String[])</CODE></A> method can be used to find matching nodes of a treebank from the command line.

 <p>
 Currently supported node/node relations and their symbols:
 <p>
 <table border = "1">
 <tr><th>Symbol<th>Meaning
 <tr><td>A &lt;&lt; B <td>A dominates B
 <tr><td>A &gt;&gt; B <td>A is dominated by B
 <tr><td>A &lt; B <td>A immediately dominates B
 <tr><td>A &gt; B <td>A is immediately dominated by B
 <tr><td>A &#36; B <td>A is a sister of B (and not equal to B)
 <tr><td>A .. B <td>A precedes B
 <tr><td>A . B <td>A immediately precedes B
 <tr><td>A ,, B <td>A follows B
 <tr><td>A , B <td>A immediately follows B
 <tr><td>A &lt;&lt;, B <td>B is a leftmost descendant of A
 <tr><td>A &lt;&lt;- B <td>B is a rightmost descendant of A
 <tr><td>A &gt;&gt;, B <td>A is a leftmost descendant of B
 <tr><td>A &gt;&gt;- B <td>A is a rightmost descendant of B
 <tr><td>A &lt;, B <td>B is the first child of A
 <tr><td>A &gt;, B <td>A is the first child of B
 <tr><td>A &lt;- B <td>B is the last child of A
 <tr><td>A &gt;- B <td>A is the last child of B
 <tr><td>A &lt;` B <td>B is the last child of A
 <tr><td>A &gt;` B <td>A is the last child of B
 <tr><td>A &lt;i B <td>B is the ith child of A (i > 0)
 <tr><td>A &gt;i B <td>A is the ith child of B (i > 0)
 <tr><td>A &lt;-i B <td>B is the ith-to-last child of A (i > 0)
 <tr><td>A &gt;-i B <td>A is the ith-to-last child of B (i > 0)
 <tr><td>A &lt;: B <td>B is the only child of A
 <tr><td>A &gt;: B <td>A is the only child of B
 <tr><td>A &lt;&lt;: B <td>A dominates B via an unbroken chain (length > 0) of unary local trees.
 <tr><td>A &gt;&gt;: B <td>A is dominated by B via an unbroken chain (length > 0) of unary local trees.
 <tr><td>A &#36;++ B <td>A is a left sister of B (same as &#36;.. for context-free trees)
 <tr><td>A &#36;-- B <td>A is a right sister of B (same as &#36;,, for context-free trees)
 <tr><td>A &#36;+ B <td>A is the immediate left sister of B (same as &#36;. for context-free trees)
 <tr><td>A &#36;- B <td>A is the immediate right sister of B (same as &#36;, for context-free trees)
 <tr><td>A &#36;.. B <td>A is a sister of B and precedes B
 <tr><td>A &#36;,, B <td>A is a sister of B and follows B
 <tr><td>A &#36;. B <td>A is a sister of B and immediately precedes B
 <tr><td>A &#36;, B <td>A is a sister of B and immediately follows B
 <tr><td>A &lt;+(C) B <td>A dominates B via an unbroken chain of (zero or more) nodes matching description C
 <tr><td>A &gt;+(C) B <td>A is dominated by B via an unbroken chain of (zero or more) nodes matching description C
 <tr><td>A .+(C) B <td>A precedes B via an unbroken chain of (zero or more) nodes matching description C
 <tr><td>A ,+(C) B <td>A follows B via an unbroken chain of (zero or more) nodes matching description C
 <tr><td>A &lt;&lt;&#35; B <td>B is a head of phrase A
 <tr><td>A &gt;&gt;&#35; B <td>A is a head of phrase B
 <tr><td>A &lt;&#35; B <td>B is the immediate head of phrase A
 <tr><td>A &gt;&#35; B <td>A is the immediate head of phrase B
 <tr><td>A == B <td>A and B are the same node
 <tr><td>A : B<td>[this is a pattern-segmenting operator that places no constraints on the relationship between A and B]
 </table>
 <p> Label descriptions can be literal strings, which much match labels
 exactly, or regular expressions in regular expression bars: /regex/.
 Literal string matching proceeds as String equality.
 In order to prevent ambiguity with other Tregex symbols, only standard
 "identifiers" are allowed as literals, i.e., strings matching
 [a-zA-Z]([a-zA-Z0-9_])* .
 If you want to use other symbols, you can do so by using a regular
 expression instead of a literal string.
 A disjunctive list of literal strings can be given separated by '|'.
 The special string '__' (two underscores) can be used to match any
 node.  (WARNING!!  Use of the '__' node description may seriously
 slow down search.)  If a label description is preceded by '@', the
 label will match any node whose <em>basicCategory</em> matches the
 description.  <emph>NB: A single '@' thus scopes over a disjunction
 specified by '|': @NP|VP means things with basic category NP or VP.
 </emph> The basicCategory is defined according to a Function
 mapping Strings to Strings, as provided by
 <A HREF="../../../../../edu/stanford/nlp/trees/AbstractTreebankLanguagePack.html#getBasicCategoryFunction()"><CODE>AbstractTreebankLanguagePack.getBasicCategoryFunction()</CODE></A>.
 Label description regular expressions are matched as <code>find()</code>,
 as in Perl/tgrep;
 you need to specify <code>^</code> or <code>$</code> to constrain matches.
 <p/>
 In a chain of relations, all relations are relative to the first node in
 the chain. For example, <code> (S &lt; VP &lt; NP) </code> means
 "an S over a VP and also over an NP".
 If instead what you want is an S above a VP above an NP, you should write
 "<code>S &lt; (VP &lt; NP)</code>".
 <p> Nodes can be grouped using parens '(' and ')'
 as in <code> S &lt; (NP $++ VP) </code> to match an S
 over an NP, where the NP has a VP as a right sister.

 <h3>Boolean relational operators</h3>

 <p> Relations can be combined using the '&' and '|' operators, negated with the '!' operator, and made optional with the '?' operator.  Thus
 <code> (NP < NN | < NNS) </code> will match an NP node dominating either
 an NN or an NNS.  <code> (NP > S & $++ VP) </code> matches an NP that
 is both under an S and has a VP as a right sister.

 <p> Relations can be grouped using brackets '[' and ']'.  So the
 expression

 <blockquote>
 <code> NP [< NN | < NNS] & > S </code>
 </blockquote>

  matches an NP that (1) dominates either an NN or an NNS, and (2) is under an S.  Without
 brackets, & takes precedence over |, and equivalent operators are
 left-associative.  Also note that & is the default combining operator if the
 operator is omitted in a chain of relations, so that the two patterns are equivalent:

 <blockquote>
 <code> (S < VP < NP) </code><br>
 <code> (S < VP & < NP) </code>
 </blockquote>

 As another example, <code> (VP < VV | < NP % NP)
 </code> can be written explicitly as <code> (VP [< VV | [< NP & % NP] ] )
 </code>

 <p> Relations can be negated with the '!' operator, in which case the
 expression will match only if there is no node satisfying the relation.
 For example <code> (NP !< NNP) </code> matches only NPs not dominating
 an NNP.  Label descriptions can also be negated with '!': (NP < !NNP|NNS) matches
 NPs dominating some node that is not an NNP or an NNS.

 <p> Relations can be made optional with the '?' operator.  This way the
 expression will match even if the optional relation is not satisfied.  This is useful when used together
  with node naming (see below).

 <p><h3>Basic Categories</h3>

 <p> In order to consider only the "basic category" of a tree label,
 i.e. to ignore functional tags or other annotations on the label,
 prefix that node's description with the &#64; symbol.  For example
 <code> (@NP < @/NN.?/) </code>  This can only be used for individual nodes;
 if you want all nodes to use the basic category, it would be more efficient
 to use a <A HREF="../../../../../edu/stanford/nlp/trees/TreeNormalizer.html" title="class in edu.stanford.nlp.trees"><CODE>TreeNormalizer</CODE></A> to remove functional
 tags before passing the tree to the TregexPattern.

 <p><h3>Segmenting patterns</h3>

 <p>The ":" operator allows you to segment a pattern into two pieces.  This can simplify your pattern writing.  For example,
 the pattern

 <blockquote>
   S : NP
 </blockquote>

 matches only those S nodes in trees that also have an NP node.

 <p><h3>Naming nodes</h3>

 <p> Nodes can be given names (a.k.a. handles) using '='.  A named node will be stored in a
 map that maps names to nodes so that if a match is found, the node
 corresponding to the named node can be extracted from the map.  For
 example <code> (NP < NNP=name) </code> will match an NP dominating an NNP
 and after a match is found, the map can be queried with the
 name to retreived the matched node using <A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexMatcher.html#getNode(java.lang.String)"><CODE>TregexMatcher.getNode(String o)</CODE></A>
 with (String) argument "name" (<it>not</it> "=name").
 Note that you are not allowed to name a node that is under the scope of a negation operator (the semantics would
 be unclear, since you can't store a node that never gets matched to).
 Trying to do so will cause a <A HREF="../../../../../edu/stanford/nlp/trees/tregex/ParseException.html" title="class in edu.stanford.nlp.trees.tregex"><CODE>ParseException</CODE></A> to be thrown. Named nodes <it>can be put within the scope of an optionality operator</it>.

 <p> Named nodes that refer back to previous named nodes need not have a node
 description -- this is known as "backreferencing".  In this case, the expression
 will match only when all instances of the same name get matched to the same tree node.
 For example: the pattern

 <blockquote>
 <code> (@NP <, (@NP $+ (/,/ $+ (@NP $+ /,/=comma))) <- =comma) </code>
 </blockquote>

 matches only an NP dominating exactly the sequence <code>NP , NP ,</code> -- the mother NP cannot have any other daughters. Multiple
 backreferences are allowed.  If the node w/ no node description does not refer
 to a previously named node, there will be no error, the expression simply will
 not match anything.

 <p> Another way to refer to previously named nodes is with the "link" symbol: '~'.
 A link is like a backreference, except that instead of having to be <i>equal to</i> the
 referred node, the current node only has to match the label of the referred to node.
 A link cannot have a node description, i.e. the '~' symbol must immediately follow a
 relation symbol.

 <p><h3>Customizing headship and basic categories</h3>

 <p> The HeadFinder used to determine heads for the head relations <code>&lt;#</code>, <code>&gt;#</code>, <code>&lt;&lt;#</code>, and <code>&gt;&gt;#</code>, and also
 the Function mapping from labels to Basic Category tags can be
 chosen by using a <A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPatternCompiler.html" title="class in edu.stanford.nlp.trees.tregex"><CODE>TregexPatternCompiler</CODE></A>.

 <p><h3>Variable Groups</h3>

 <p> If you write a node description using a regular expression, you can assign its matching groups to variable names.
 If more than one node has a group assigned to the same variable name, then matching will only occur when all such groups
 capture the same string.  This is useful for enforcing coindexation constraints.  The syntax is

 <blockquote>
 <code> / &lt;regex-stuff&gt; /#&lt;group-number&gt;%&lt;variable-name&gt;</code>
 </blockquote>

 For example, the pattern (designed for Penn Treebank trees)

 <blockquote>
 <code> @SBAR < /^WH.*-([0-9]+)$/#1%index << (__=empty < (/^-NONE-/ < /^\*T\*-([0-9]+)$/#1%index)) </code>
 </blockquote>

 will match only such that the WH- node under the SBAR is coindexed with the trace node that gets the name <code>empty</code>.


 <p><h3>Current known bugs/shortcomings:</h3>

 <ul>

 <li> Due to the lack of parent pointers in <A HREF="../../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees"><CODE>Tree</CODE></A>s, parents are found via
 exhaustive depth-first search from the root.  This is a serious efficiency bottleneck.

 </ul>
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Galen Andrew, Roger Levy (rog@csli.stanford.edu), Anna Rafferty (filter mode)</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../../serialized-form.html#edu.stanford.nlp.trees.tregex.TregexPattern">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.TRegexTreeReaderFactory.html" title="class in edu.stanford.nlp.trees.tregex">TregexPattern.TRegexTreeReaderFactory</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html" title="class in edu.stanford.nlp.trees.tregex">TregexPattern</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#compile(java.lang.String)">compile</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;tregex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a pattern from the given string using the default Headfinder and
 BasicCategoryFunction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#main(java.lang.String[])">main</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out all matches of a tree pattern on each tree in the path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexMatcher.html" title="class in edu.stanford.nlp.trees.tregex">TregexMatcher</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#matcher(edu.stanford.nlp.trees.Tree)">matcher</A></B>(<A HREF="../../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a <A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexMatcher.html" title="class in edu.stanford.nlp.trees.tregex"><CODE>TregexMatcher</CODE></A> for this pattern on this tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#pattern()">pattern</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#prettyPrint()">prettyPrint</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print a multi-line respresentation of the pattern illustrating
 it's syntax to System.out.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#prettyPrint(java.io.PrintStream)">prettyPrint</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/PrintStream.html?is-external=true" title="class or interface in java.io">PrintStream</A>&nbsp;ps)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print a multi-line respresentation
 of the pattern illustrating it's syntax.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#prettyPrint(java.io.PrintWriter)">prettyPrint</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/PrintWriter.html?is-external=true" title="class or interface in java.io">PrintWriter</A>&nbsp;pw)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print a multi-line respresentation
 of the pattern illustrating it's syntax.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html" title="class in edu.stanford.nlp.trees.tregex">TregexPattern</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#safeCompile(java.lang.String, boolean)">safeCompile</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;tregex,
            boolean&nbsp;verbose)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a pattern from the given string using the default Headfinder and
 BasicCategoryFunction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#setPatternString(java.lang.String)">setPatternString</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;patternString)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="matcher(edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
matcher</H3>
<PRE>
public <A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexMatcher.html" title="class in edu.stanford.nlp.trees.tregex">TregexMatcher</A> <B>matcher</B>(<A HREF="../../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t)</PRE>
<DL>
<DD>Get a <A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexMatcher.html" title="class in edu.stanford.nlp.trees.tregex"><CODE>TregexMatcher</CODE></A> for this pattern on this tree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t</CODE> - a tree to match on
<DT><B>Returns:</B><DD>a TregexMatcher</DL>
</DD>
</DL>
<HR>

<A NAME="compile(java.lang.String)"><!-- --></A><H3>
compile</H3>
<PRE>
public static <A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html" title="class in edu.stanford.nlp.trees.tregex">TregexPattern</A> <B>compile</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;tregex)
                             throws <A HREF="../../../../../edu/stanford/nlp/trees/tregex/ParseException.html" title="class in edu.stanford.nlp.trees.tregex">ParseException</A></PRE>
<DL>
<DD>Creates a pattern from the given string using the default Headfinder and
 BasicCategoryFunction.  If you want to use a different HeadFinder or
 BasicCategoryFunction, use a <A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPatternCompiler.html" title="class in edu.stanford.nlp.trees.tregex"><CODE>TregexPatternCompiler</CODE></A> object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tregex</CODE> - the pattern string
<DT><B>Returns:</B><DD>a TregexPattern for the string.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../edu/stanford/nlp/trees/tregex/ParseException.html" title="class in edu.stanford.nlp.trees.tregex">ParseException</A></CODE> - if the string does not parse</DL>
</DD>
</DL>
<HR>

<A NAME="safeCompile(java.lang.String, boolean)"><!-- --></A><H3>
safeCompile</H3>
<PRE>
public static <A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html" title="class in edu.stanford.nlp.trees.tregex">TregexPattern</A> <B>safeCompile</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;tregex,
                                        boolean&nbsp;verbose)</PRE>
<DL>
<DD>Creates a pattern from the given string using the default Headfinder and
 BasicCategoryFunction.  If you want to use a different HeadFinder or
 BasicCategoryFunction, use a <A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPatternCompiler.html" title="class in edu.stanford.nlp.trees.tregex"><CODE>TregexPatternCompiler</CODE></A> object.
 Rather than throwing an exception when the string does not parse,
 simply returns null
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tregex</CODE> - the pattern string<DD><CODE>verbose</CODE> - whether to log errors when the string doesn't parse
<DT><B>Returns:</B><DD>a TregexPattern for the string, or null if the string does not parse.</DL>
</DD>
</DL>
<HR>

<A NAME="pattern()"><!-- --></A><H3>
pattern</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>pattern</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setPatternString(java.lang.String)"><!-- --></A><H3>
setPatternString</H3>
<PRE>
public void <B>setPatternString</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&nbsp;patternString)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public abstract <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>toString</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true#toString()" title="class or interface in java.lang">toString</A></CODE> in class <CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A single-line string representation of the pattern</DL>
</DD>
</DL>
<HR>

<A NAME="prettyPrint(java.io.PrintWriter)"><!-- --></A><H3>
prettyPrint</H3>
<PRE>
public void <B>prettyPrint</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/PrintWriter.html?is-external=true" title="class or interface in java.io">PrintWriter</A>&nbsp;pw)</PRE>
<DL>
<DD>Print a multi-line respresentation
 of the pattern illustrating it's syntax.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="prettyPrint(java.io.PrintStream)"><!-- --></A><H3>
prettyPrint</H3>
<PRE>
public void <B>prettyPrint</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/PrintStream.html?is-external=true" title="class or interface in java.io">PrintStream</A>&nbsp;ps)</PRE>
<DL>
<DD>Print a multi-line respresentation
 of the pattern illustrating it's syntax.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="prettyPrint()"><!-- --></A><H3>
prettyPrint</H3>
<PRE>
public void <B>prettyPrint</B>()</PRE>
<DL>
<DD>Print a multi-line respresentation of the pattern illustrating
 it's syntax to System.out.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="main(java.lang.String[])"><!-- --></A><H3>
main</H3>
<PRE>
public static void <B>main</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>[]&nbsp;args)
                 throws <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Prints out all matches of a tree pattern on each tree in the path.
 Usage: <br><br><code>
 java edu.stanford.nlp.trees.tregex.TregexPattern [[-TCwfosnu] [-filter] [-h &lt;node-name&gt;]]* pattern
  filepath   </code>

 <p>
 Arguments:<br>
 <ul><li><code>pattern</code>: the tree
 pattern which optionally names some set of nodes (i.e., gives it the "handle") <code>=name</code> (for some arbitrary
 string "name")
 <li> <code>filepath</code>: the path to files with trees. If this is a directory, there will be recursive descent and the pattern will be run on all files beneath the specified directory.
 </ul><p>
 Options:<br>
 <ul><li> <code>-T</code> causes all trees to be printed as processed.  Otherwise only matching nodes
 are printed.
 <li> <code>-C</code> suppresses printing of matches, so only the
 number of matches is printed.
 <li> <code>-w</code> causes the whole of a tree that matches to be printed.
 <li> <code>-f</code> causes the filename to be printed.
 <li> <code>-i &lt;filename&gt;</code> causes the pattern to be matched to be read from <code>&lt;filename&gt;</code> rather than the command line.  Don't specify a pattern when this option is used.
 <li> <code>-o</code> allows each tree node to be reported only once as the root of a match (by default a node will
 be printed once for every <em>way</em> the pattern matches).
 <li> <code>-s</code> causes trees to be printed all on one line (by default they are pretty printed).
 <li> <code>-n</code> causes the number of the tree in which the match was found to be
 printed before every match.
 <li> <code>-u</code> causes only the label of each matching node to be printed.
 <li> <code>-t</code> causes only the yield of the selected node (or the yield of the whole tree, if the <code>-w</code> option is used) to be printed.
 <li> <code>-encoding &lt;charset_encoding&gt;</code> option allows specification of character set.
 <li> <code>-h &lt;node-handle&gt;</code> If an <code>-h</code> option is given, the root tree node will not be printed.  Instead,
 for each <code>node-handle</code> specified, the node matched and given that handle will be printed.  Multiple nodes can be printed by using the
 <code>-h</code> option multiple times on a single command line.
 <li> <code>-hf &lt;headfinder-class-name&gt;</code> use the specified <A HREF="../../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees"><CODE>HeadFinder</CODE></A> class to determine headship relations.
 <li> <code>-hfArg &lt;string&gt;</code> pass a string argument in to the <A HREF="../../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees"><CODE>HeadFinder</CODE></A> class's constructor.  <code>-hfArg</code> can be used multiple times to pass in multiple arguments.
 <li> <code>-trf &lt;TreeReaderFactory-class-name&gt;</code> use the specified <A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.TRegexTreeReaderFactory.html" title="class in edu.stanford.nlp.trees.tregex"><CODE>TregexPattern.TRegexTreeReaderFactory</CODE></A> class to read trees from files.
 <li> <code>-v</code> print every tree that contains no matches of the specified pattern, but print no matches to the pattern.

 <li> <code>-x</code> Instead of the matched subtree, print the matched subtree's identifying number as defined in <tt>tgrep2</tt>:a
 unique identifier for the subtree and is in the form s:n, where s is an integer specifying
 the sentence number in the corpus (starting with 1), and n is an integer giving the order
 in which the node is encountered in a depth-first search starting with 1 at top node in the
 sentence tree.

 <li> <code>-extract &lt;code&gt; &lt;tree-file&gt;</code> extracts the subtree s:n specified by <tt>code</tt> from the specified <tt>tree-file</tt>.  Overrides all other behavior of tregex.  Can't specify multiple encodings etc. yet.
 <li> <code>-extractFile &lt;code-file&gt; &lt;tree-file&gt;</code> extracts every subtree specified by the subtree codes in <tt>code-file</tt>, which must appear exactly one per line, from the specified <tt>tree-file</tt>.  Overrides all other behavior of tregex. Can't specify multiple encodings etc. yet.
 <li> <code>-filter</code> causes this to act as a filter, reading tree input from stdin

 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexParserTokenManager.html" title="class in edu.stanford.nlp.trees.tregex"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.TRegexTreeReaderFactory.html" title="class in edu.stanford.nlp.trees.tregex"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?edu/stanford/nlp/trees/tregex/TregexPattern.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="TregexPattern.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<FONT SIZE=2><A HREF="http://nlp.stanford.edu">Stanford NLP Group</A></FONT>
</BODY>
</HTML>
